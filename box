#!/bin/zsh
emulate -L zsh
#setopt xtrace
typeset -A retval_kv
typeset -i retval_i
typeset retval

trap 'echo "Command returned nonzero exit code" >&2' ZERR

typeset PROGNAME="${0##*/}"

typeset -a box_path
typeset box_userdir="$HOME/.box"
if [[ -d "$box_userdir" ]]; then
	[[ -f "$box_userdir/config" ]] && source "$box_userdir/config"
	[[ -d "$box_userdir/tools" ]] && box_path+=( "$box_userdir/tools" )
fi

# Boostrap functions: These will be replaced once we are fully initialized.
function assert {
	if ! eval "$*"; then
		echo "Assertion failed during bootstrap" >&2
		exit 255
	fi
}
# End bootstrap functions

typeset -ga box_loaded_tools
typeset -ga box_tool_destructors

function _box_is_defined {
	assert "[[ $# -eq 1 ]]"
	(( ${+functions[$1]} ))
}

function _box_run_if_defined {
	assert "[[ $# -eq 1 ]]"
	_box_is_defined "$1" && "$1"
}

function _box_tool_constructor {
	assert "[[ $# -eq 1 ]]"
	local toolname="${1##*/}" toolfile="$1"
	assert "[[ -f $toolfile ]]"

	source "$toolfile"
	box_loaded_tools+=( "$toolname" )
	_box_run_if_defined "${toolname}_constructor"
	local fname="_box_${toolname}_destructor"
	local cleanup="function $fname {; "
	_box_is_defined "${toolname}_constructor" && cleanup+="unset -f ${toolname}_constructor; "
	if _box_is_defined "${toolname}_destructor"; then
		cleanup+="${toolname}_destructor; "
		cleanup+="unset -f ${toolname}_destructor; "
	fi
	if ! _box_is_defined "${toolname}_help"; then
		eval "function ${toolname}_help {
			retval=()
		}"
	fi
	cleanup+="unset -f ${toolname}_help; "
	cleanup+="unset -f $fname; }"
	eval "$cleanup"
	box_tool_destructors+=( "$fname" )
	return 0
}

function box_tool_loaded {
	assert "[[ $# -eq 1 ]]"
	(( ${+box_loaded_tools[(r)*${1}]} ))
}

function _box_zmodload {
	assert "[[ $# -eq 1 ]]"

	local modname="$1"
	zmodload "$modname" 2>/dev/null || return 1
	local fname="_box_${modname}_destructor"
	eval "function $fname {
		zmodload -u $modname
		unset -f $fname
	}"
	box_tool_destructors+=( "$fname" )
	box_loaded_tools+="$modname"
}

function _box_tool_destructor {
	# Can't call assert here because this is called late enough that assert
	# might have been undefined already

	$box_tool_destructors[$1]
	box_tool_destructors[$1]=()
	box_loaded_tools[$1]=()
}

# Global Functions
function path_search {
	assert "[[ $# == 1 ]]"
	assert "(( $+path_search_arg ))"

	typeset -a path
	path=( "$path_search_arg[@]" )
	retval=( ${(f)"$(whence -p "$1")"} )
}

function grab {
	assert "[[ $# -ne 0 ]]"
	assert "[[ -n \"$*\" ]]"

	local tool path_search_arg
	for tool in "$@"; do
		[[ -z "$tool" ]] && return 1
		box_tool_loaded "$tool" && continue
		path_search_arg=( "$box_path[@]" )
		if ! path_search "$tool"; then
			_box_zmodload "$tool" || return 1
		else
			_box_tool_constructor "$retval" || return 1
		fi
	done
}

function exit {
	unsetopt xtrace
	assert "[[ $# -le 1 ]]"
	typeset -i i
	for (( i = $#box_tool_destructors; i > 0; i-- )); do
		_box_tool_destructor $i
	done
	unset -f _box_tool_destructor _box_zmodload _box_is_defined
	unset -f _box_tool_constructor _box_run_if_defined
	unset -f grab path_search
	unset box_loaded_tools box_tool_destructors help
	unset PROGNAME box_path box_userdir retval
	unset -f exit
	builtin exit ${1:-0}
}
# End Global Functions

trap 'exit $?' EXIT

grab colors
trap 'echo "${fg_bold[red]}*${reset_color} Command returned nonzero exit code" >&2' ZERR
grab assert

grab zsh/zutil
zparseopts -E -K -D h=help -help=help

if [[ $PROGNAME == "box" ]]; then
	[[ "$1" == "help" ]] && typeset help
	if (( $+help )); then
		grab help
		usage
		echo
		help
		exit
	fi

	if [[ -z "$1" ]] || ! grab "$1"; then
		grab help
		usage >&2
		exit 1
	fi
	"$@"
else
	grab $0(:t)
	$0(:t) "$@"
fi
